# 调用约定




# 函数的参数传递（x86）

函数传递参数有3种方式，分别是栈方式、寄存器方式及通过全局变量进行隐含参数传递的方式。

常用调用约定

| 调用类型         | `__cdecl`（C规范） | `pascal` | `stdcall` | `Fastcall`     |
| ---------------- | ------------------ | -------- | --------- | -------------- |
| 参数传递顺序     | 从右到左           | 从左到右 | 从右到左  | 使用寄存器和栈 |
| 平衡栈者         | 调用者             | 子程序   | 子程序    | 子程序         |
| 允许使用`VARARG` | 是                 | 否       | 否        |                |

**注：**`VARARG`表示参数的个数可以是不确定的

## 利用栈传递参数

### `__cdecl`（C规范）调用约定

参数按照从右到左的顺序入栈，由调用者负责清除栈。

`__cdecl`是C和C&#43;&#43;程序的默认调用约定。C/C&#43;&#43;和MFC程序默认使用的调用约定是`__cdecl`，也可以在函数声明时加上`__cdecl`关键字来手动指定。

```assembly
push par3		;参数从右到左传递
push par2
push par1
call test1
add esp, 0C		;返回后平衡栈
```

### `pascal`调用约定

参数从左到右的顺序压入栈，要求被调用函数负责清除栈

```assembly
push par1		;参数从左到右传递
push par2
push par3
call test1		;函数内平衡栈
```

### `stdcall`调用约定

参数按从右到左的顺序入栈，并由被调用的函数在返回前清理传送参数的内存站，函数参数的个数固定。

```assembly
push par3		;参数从右到左传递
push par2
push par1
call test1		;函数内平衡栈
```

## 利用寄存器传递参数

### `Fastcall`调用约定

寄存器传递参数的方式没有标准，但绝大多数编译器提供商都在不对兼容性进行声明的情况下遵循相应的规范，即`Fastcall`规范

#### `Fastcall`——`Microsoft Visual C&#43;&#43; 编译器`

左边的2个不大于4个（DWORD）参数分别放在`ecx`和`edx`寄存器中，寄存器用完后就要使用栈，其余参数仍然按从右到左的顺序压入栈，被调用的函数在返回前清理传送参数的栈。

浮点值、远指针、`__int64`类型总是通过栈来传递的。

#### `Fastcall`——`Borland Delphi/C&#43;&#43; 编译器`

左边的三个不大于4字节（DWORD）的参数分别放在`eax`、`edx`、`ecx`寄存器中，寄存器用完后，其余参数按照从左至右的`PASCAL`方式压入栈

#### `Fastcall`——`Watcom C 编译器`

总是通过寄存器来传递参数，严格为每一个参数分配一个寄存器，默认情况下第一个参数用`eax`，第二个参数用`edx`，第三个参数用`ebx`，第四个参数用`ecx`，如果寄存器用完，就会用栈来传递参数。

`Watcom C`可以由程序员指定任意一个寄存器来传递参数，因此，其参数实际上可能通过任何寄存器进行传递。

### `thiscall`调用约定

是C&#43;&#43;中的非静态类成员函数的默认调用约定，对象的每个函数隐含接受`this`参数。

参数按照从右到左的顺序入栈，被调用的函数在返回前清理传送参数的栈，仅通过`ecx`寄存器传送一个额外的参数——`this`指针

## 名称修饰约定

为了允许使用操作符和函数重载，C&#43;&#43;编译器往往会按照某种规则改写每一个口点的函数名，从而允许同一个名字有多个用法且不会破坏现有的基于C的链接器。这项技术挺长成为名称改变或者名称修饰。

以VC&#43;&#43;为例

### C 编译时函数名修饰约定规则

- `stdcall`调用约定在输出函数名前面加一个下划线前缀，在后面加一个&#34;@&#34;符号及其参数的字节数，格式为&#34;`_functionname@number`&#34;
- `__cdecl`调用约定仅在输出函数名前面加一个下划线前缀，格式为&#34;`_functionname`&#34;
- `Fastcall`调用约定在输出函数名前面加一个&#34;@&#34;符号，在后面加一个&#34;@&#34;符号及其参数的字节数，格式为&#34;`@functionname@number`&#34;

它们均不改变输出函数名中的字符大小写。这和`pascal`调用约定不同。`pascal`约定输出的函数名不能有任何修饰且全部为大写

### C&#43;&#43; 编译时函数名修饰约定规则

- `stdcall`调用约定以&#34; ? &#34;标识函数名的开始，后跟函数名；

  在函数名后面，以&#34; @@YG &#34;标识参数表的开始，后跟参数表；

  参数表的第 1 项为该函数的返回值类型，其后依次为参数的数据类型，指针标识在其所指数据类型前；

  在参数表后面，以&#34; @Z &#34;标识整个名字的结束(如果该函数没有参数，则以&#34;Z&#34;标识结束)。

  其格式为&#34;`?functionname@@YG*****@Z`&#34;或&#34;`?functionname@@YG*XZ`&#34;

- `__cdecl`调用约定规则与上面的`stdcall`调用约定规则相同，只是参数表的开始标识由&#34;`@@YG`&#34;变成了&#34;`@@YA`&#34;

- `Fastcall`调用约定规则与上面的`stdcall`调用约定规则相同，只是参数表的开始标识由&#34;`@@YG`&#34;变成了&#34;`@@YI`&#34;

# 函数的参数（x64）

## 调用约定

x86应用程序的函数调用有`stdcall、__cdecl、Fastcall`等方式，但x64应用程序只有一种寄存器快速调用约定。

前 4 个参数使用固定的寄存器传递，第 1 个参数`rcx`，第 2 个参数`rdx`，第 3 个参数`r8`，第 4 个参数`r9`，其他参数从右往左依次入栈。

任何大于8字节或者不是1字节、2字节、4字节、8字节的参数必须由引用来传递（地址传递）。所有浮点参数的传递都是使用`XMM`寄存器完成的，它们在`XMM0、XMM1、XMM2、XMM3`中传递

| 参数        | 类型  | 浮点类型 |
| ----------- | ----- | -------- |
| 第 1 个参数 | `rcx` | `XMM0`   |
| 第 2 个参数 | `rdx` | `XMM1`   |
| 第 3 个参数 | `r8`  | `XMM2`   |
| 第 4 个参数 | `r9`  | `XMM3`   |

**注：**如果参数既有浮点类型，又有整形，例如`void fun(float, int, float, int)`，那么参数传递顺序为第 1 个参数（`XMM0`）、第 2 个参数（`rdx`）、第 3 个参数（`XMM2`）、第 4 个参数（`r9`）

函数的前4个参数虽然使用了寄存器来传递，但是栈仍然为这4个参数预留了空间（32字节），称为预留栈空间。为了避免函数功能比较复杂时，寄存器不够用，可以使用预留栈空间。方法是函数调用者多申请32字节的栈空间，当函数寄存器不够用时，可以把寄存器的值保存到刚才申请的栈空间中。

预留栈空间由函数调用者提前申请。由函数调用者负责平衡栈空间。


---

> 作者: lo1see  
> URL: http://localhost:1313/posts/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/  

